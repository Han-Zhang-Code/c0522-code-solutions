User can sign up:
Create a post route and direct path to sign up session, get the username and password from request.body
If no username or password, throw an 400 error. use hash method to hash the password provided then use sql statement to insert the new username and hashed password to the database. create an app component and set the constructor with three initial states: user, isAuthorizing and route, mount the route to the sign-up path render the sign-up page and return to a new component Auth. create a the new class component Auth in other file and destructure user, route, and handleSignIn from this.context which contains properties from app component.  create a welcome message according to route.path and return to a new component called AuthForm. create the new class component called AuthForm,  set the constructor with two initial states: username and password, create a new function inside the class component called handleChange and pass event as it parameter, destructure the event.target and assign that value to two const variable name and value, use the setState to change the initial state accordingly, this is where the browser takes user's input. Create another function called handleSubmit, destructure the action property from props and assigned to const variable action, setup header for fetch method, pass the state value to body. fetch the path to according to action, if the action is sign-up, go to sign-in page. Render the form and put handleSubmit on form’s onSubmit attribute, and put handleChange on each input’s onChange attribute.
User can sign in:
Create a post route and direct path to sign in session and get the username and password from request.body, if no username or password, throw an 401 error, use sql to select the userId and hashed password depend on the username, get the user from result.rows, if no user found throw a 401 error.  Destructure the userID and hashedPassword from the result.row. then use argon2.verify the hashedPassword with the password provided by the user, if not matching throw a 401 error, if did match, assign both userID and username to a const variable payload, then use sign method of jwt object to produce a token with payload and the TOKEN_SECRET in the env file.send token and payload back to client from the server. define a new function called handleSignIn and pass result to parameter, destructure the user and token from the result, this result will be the result received from the server which contains a token and a payload. use setState method to change the current state to the current user. Render the sign-in path which will return to the Auth component we created in previous.  Change the welcome message and AuthForm according the route.path. in the fetch method of the handleSubmit function of AuthForm component, if result.user and result.token exist, call the handleSignIn function inherited from Auth component which inherited from App component.
User can stay sign-in:
In the handleSignIn function of app class component, store the token to the localStorage under the name ‘react-context-jwt’, . In the componentDidMount function of app class component, define const variable token and retrieve the token from localStorage under the name ‘react-context-jwt’, , if the token exist, assign the token to user and assign isAuthorizing to false, else assign user to null.  In the render function, if isAuthorizing is false, the app will run renderPage function, if its true, the render function will return to null. In the Auth component, if the user exists, the path will Redirect to the home page.
User can sign-out:
Define a function in App class component called handleSignOut, which will remove the token from localStorage and reset user in state to null. call the handleSignOut function from Navbar component.
